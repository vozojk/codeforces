AksLolCoding is playing a game on a string s of length n. Initially, s contains only lowercase Latin characters. In one turn, AksLolCoding can choose any pair of integers (i, j) such that 1 <= i < j <= n; s[i] == s[j] and neither is already a *; and s[k] == * for all characters between i and j (where i < k < j). If no such i, j exists, then the game ends.

Otherwise, AksLolCoding sets both s[i] and s[j] to *. Once the game ends, AksLolCoding wins if and only if every character in s is equal to *.
Determine if it is possible for AksLolCoding to win. Note: * represents ASCII character 42.

Input: The first line contains an integer t (1 <= t <= 100), the number of test cases. The first line of each test case contains an integer n (1 <= n <= 5000), the length of the string.
The second line of each test case contains a string s consisting of lowercase Latin characters.
The sum of n over all test cases does not exceed 5000.

Output: Output the answer to each test case on its own line.
If AksLolCoding can win, output YES (without quotes). Else, output NO (without quotes).
You can output the answer in any case (upper or lower). For example, the strings yEs, yes, Yes, and YES will be recognized as positive responses.

Strategy: This was surprisingly fine. My first C problem. It key is realizing that the stairs being there are the same if there wasnt anything at all and we can remove the numbers only in pairs. Since the letters need to be next to eachother to remove them it does not matter what pair we remove in an n sized block of the same letter, because all the other ones will get squished next to eachother again. Therefore, we can just scan the array until the size is 0 and keep a boolean to check if anything dissapeared each scan. If it didn't it's not gonna magically appear next time and if at that point the array is not empty we can conclude it can never be. Also, all the odd sized arrays output "NO". We run a while loop until the size==0, if the loop exits and the size is 0 we output "YES".