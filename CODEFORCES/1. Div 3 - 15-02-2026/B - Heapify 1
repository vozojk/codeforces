You are given a permutation a of length n.

You can perform the following operation any number of times (possibly zero):

Select an index i (1≤i≤n/2), and swap a(i) and a(2i).

For example, when a=[1,4,2,3,5], you can swap a2 and a4 to make it [1,3,2,4,5], but you cannot swap a2 and a3.

Please determine if the sequence a can be sorted in increasing order.


A permutation of length n is an array consisting of n distinct integers
from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation
(2 appears twice in the array), and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).

Input:
Each test contains multiple test cases. The first line contains the number of test cases t (1≤t≤104).
The description of the test cases follows.

The first line of each test case contains a single integer n (1≤n≤2⋅105).

The second line of each test case contains n distinct integers a1,a2,…,an (1≤ai≤n).

It is guaranteed that the sum of n over all test cases does not exceed 2⋅105.

Output
If a can be sorted in increasing order, output "YES" on a separate line.
Otherwise, output "NO" on a separate line.

This was a tough one. I did the classic ADHD approach, did not think about it and though I have it. For
some of my testcases it did work but it was completely wrong. My first approach was to check only for 1 swap
so i did a few checks for a back and forward swap which was buggy and stupid too but would work in the end.
Then I have realized (with the help of AI, upsolving), that any number of swaps means my approach is completely
wrong. The correct approach is to realize that by having the ability to swap a(i) and a(2i) we are creating a chain
(a(i),a(2i),a(4i),(a(i^2k)). This is a chain of numbers that can be swapped and are determined by the odd ingition
point at i. All the numbers in the chain will share a common starting point. So if we check
starting_point(a) == starting_point(b), we know we can rearrange them as we want. Therefore, if the number
in the array at index i(1 indexed) has the same starting point, there are swappable and its possible to sort
that chain, if we find a number that does not match this constraint, it could never get to it's index because the
chain does not cover it. Therefore we just scan the numbers have a counter and check
if (starting_point(counter) != starting_point(arr[counter]) we set a bool to false and at the end check
this to print either yes or no. This was my intro to graphs. Easy, but I did not realized in 2h.

