You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.

Return the length of the longest substring containing the same letter you can get after performing the above operations.

Strategy: We keep an array (since theres only 26 letters it's better than a hashmap (locality)) of the frequencies of all the characters. We use a 2 pointer strategy. For each character that gets loaded by the right pointer, we do freq[char]++ and then we check. We check if the current maximum character is still the maximum one, since we just added a new one. We do this by keeping track of the currentMax character in a separate variable. We do (freq[maxChar]<freq[current]) is this evaluates to true we change maxChar. Then we keep a variable maxLength, for this variable we check right-left(substring size)-freq[maxchar]<=k if it is, it is a valid substring and we do length = right-left. since the making the string any smaller doesn't help, we continue this way, when we will increase right we get a substring of a bigger length. For each iteration where the substring does not pass the conditions, we increase left and decrease freq[left], this way we get rid of the left letters when they dont work out with the right letters and keep the rule that the substring will only get bigger with found candidates for the biggest one since for a valid substring we don't do anything so the size increases by 1 and for an invalid substring the for loop does right++ and at the end we do left--, which just shifts the window.