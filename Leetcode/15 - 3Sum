Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.

Notice that the solution set must not contain duplicate triplets.

Strategy: For this one I needed to do a full prep problem and it still took a bit even though the concept is pretty easy. Basically, the main idea is that since the triplet needs to have a sum of zero, one of the number will be equal to the negative sum of the other two. This will translate it to two sum for we ween to find all combinations and also ignore any duplicates. Still seems pretty hard. The first part is looping through all the letters. We do a for loop for the whole array. Then inside the while loop we need to run an edited version of 2 sum, for 2 sum the array needs to sorted so we will sort it before looping. We need to define left as i+1 since otherwise we we would just be creating duplicates since the numbers before will get checked when calling the main loop on them. We set target for the inner loop to be -nums[i] to get 0 overall. We find the target by using the classic move right left if target is smaller and move left right if the target is bigger. The twist is that if we actually find the target. We save the tripled and keep searching, but we need to ignore all the numbers we have just scanned through since we can't reuse so we shift the left AND right pointers until they point to a different number (this is done with a while loop and 1 additional shift). At the start of each inner while iteration we also skip the numbers anytime it is the same as the last one since that would create duplicates by doing the exact same thing we have just done for the previous number creating the exact same result. The inner while is for duplicates in different order. This is for straight up exact same result. Like this, we loop through the whole array finding targets. We then return a result vector<vector<int>> with all the triplets we saved when target==sum.