Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.

Implement the TimeMap class:

TimeMap() Initializes the object of the data structure.
void set(String key, String value, int timestamp) Stores the key key with the value value at the given time timestamp.
String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp. If there are multiple such values, it returns the value associated with the largest timestamp_prev. If there are no values, it returns "".


Strategy: This seems like an OOP problem. We need to define a class with certain functionality which is usually great since it looks hard but architecting it takes away difficulty from the implementation. Here, we need to keep track of values based on key subkeys which are timestamps. The logic is as follows. The main key is the string key, then there are separate timestamps. Through the timestamps we can track different values of key at different points in time. Our goal is to be able to set the value of a key at a timestamp and also retrieve that value but with a small twist. For the retrieval by timestamp, if the exact timestamp is not available, we retrieve the nearest previous one. This screams binary search and through it higher bound, since we can put in our timestamp, it will find the first bigger thing and we decrease the iterator by one to find the last <= value. So, we will keep an unordered_map<string, vector<pair<timestamp, value>>>, setting a value is easy, we just go to the right slot in the map and add a new pair to the vector, we don't even need to create it when there is nothing since the map does it by itself. For the get, we need to check if there is actually anything by using map.count()==0 since if there wasnt, doing an access would created the vector which just wastes memory. Then we use std::upper_bound which will find the next greatest timestamp, since the timestamps are coming in an increasing order and we cannot delete, the vector will always be sorted. After we get the upper bound we check if it doesn't point to the start of the vector since that would say there is nothing as small as our timestamp. If it points to the start we return "", otherwise we decrease the iterator and return the value.