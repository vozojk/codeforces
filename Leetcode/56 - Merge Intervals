Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.

Strategy: For this one we need to first define what are the rules of the game. We can merge 2 intervals if int1[1]>=int2[0] since then they overlap. This is the main thing. Then we also need to make sure we adjust the new intervals second value since if int1[1]>int2[1] we get newInt[1]=int1[1] but if int1[1]<int2[1] we get newInt[1]=int2[1]. The data structure we use for this is a stack, since we only really care about the last interval, which is the one that will always be at the top and the stack will also keep track of the previous ones nicely. So, we have mapped out the conditions. If int2[0]<=int1[1] we can merge them and then we pick the right higher bound. This is done by taking the top of the stack and if the top interval has wider bounds on both sides than the new intervals we just ignore the new one and move on. If the lower bound of the new interval is higher than the higher bound of the top one. The intervals are not overlapping and therefore we have to push the whole new interval onto the stack. If they do overlap but the higher bound of the new interval is higher than the higher bound of the top one, we update the higher bound. We traverse the whole array of intervals like that. The we can return whats in the stack.

Note: The intervals need to get sorted before doing any of this since otherwise we wouldn't know if some interval that's deep down in the stack does not need an update.