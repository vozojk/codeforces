Given an encoded string, return its decoded string.

The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.

You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4].

The test cases are generated so that the length of the output will never exceed 105.

Strategy: There are multiple things to look out for. The strings can and will be nested so it's not possible to generate them one by one since the multiplier will multiply with the more inside ones. Therefore we need a more clever algo. This boils down to the stack yet again. We need to be able to save digits in one depth level but also keep on going more down to get all of the levels to unfold. We can achieve this by having a currentStr and multiplier variables. One stores the number before the '[' and the other stores the letters inside that will get multiplied that many times. To solve the nesting, everytime we get to another '[' bracket we push the string onto a stack with strings and the multiplier onto the multiplier stack, build a new string and go more deep until we reach the deepest level which will end with a ']'. This is where is starts unfolding, with each ']' bracket we take the string we have, multiply by multiplier since we can be sure there will be no more letter for that level and append it to the string at a level 1 less deep. This is important since the string we have just created will need to get multiplied by its own multiplier. So, everytime there's an opening bracket we move more deep to calculate the deeper level and everytime a level closes we move 1 up and compile the level we know that ended. Since there are as many closing as opening brackets we will reach a point where all the levels will compile, multiplied by their proper multipliers and we will reach the final string.