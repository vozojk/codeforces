You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.

Return the max sliding window.

Strategy: This one was a hard so I was happy to solve it. The key is keeping track of the right thing. The only thing we care about is making sure we know what is the largest number in the current subarray of some fixed size k, so we center our attention at that. We need to create a state management system that will correctly and aggressively filter everything not needed. Since we need to be able to easily replace old numbers and also put in new ones, we will be using a queue (deque, since we need to pop_back also). The idea is this: We put the new numbers at the back of the queue, and we will manage it so the front always has the biggest number. This can be achieved by using 2 crucial rules. 1. Every new number, we check at the back of the queue, if the new number is bigger, we keep removing old numbers until we get to something that is bigger than the new one. This way the queue, will always have the biggest number possible at the front, since otherwise it would get replaced. The second part is to remove the numbers that are too old to be there (currentIndex-k>numberIndex), we achieve this by saving the indices of the actual numbers instead of their values, we can access the array in O(1) so this doesn't make the comparisons much slower and now we can remove anything too old. Summed up, we remove anything small and older from the back and anything to old from the front. This warrants that the number at the front will always be the biggest and also not old enough. We keep an array result[] and every iteration (new number) we save the current front of the queue to the result array. We return that array.