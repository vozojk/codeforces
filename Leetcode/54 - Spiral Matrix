Given an m x n matrix, return all elements of the matrix in spiral order.

Strategy: Classic simulation. The key is realizing that everytime we reach a bound of the matrix or a number we have already been to in our current direction, we turn right. That means there is no difficult choices. We just check if we can go straight, if we can we do, if we cant, we turn left, if we can't go straight 2 times in a row, we're in the middle of the spiral and we return. I wrote a helper to do the checks. It has a simple switch statement that checks the bound and then, based on the input direction, will check where will going 1 more forward in that direction land us. If it is possible to go there (we mark alredy visited squares by setting them to -200, low bound for the value is -100) we return true. If there is a -200 or we are of out bounds we return false. In the main loop we have a field for the current direction (0 to 3, 0 being the starting direction which is right) and an array[4][2] that has all the moves for different direction ({0,1} for right etc...). The biggest problem was realizing that the coords are inverted so going right is not [0]+1 and [1] but [0] and [1]+1 which was pretty counterintuitive. This is just a matter of setting the move array correctly. After than we just loop until we reach the center and continously call the helper to check if we have reached a bounds, if so we do dirIndex = (dirIndex+1)%4 this way we loop back to zero from 3. Each move we just save the number into a vector and return that after breaking the loop.