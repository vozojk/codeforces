Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.

You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.

Strategy: This one is unfortunately not so easy as xorring the thing. But xor is still an element in the process. We use another trick. For any 2 numbers, we get the binary digits they have different by using xor on them and since all the other numbers in the array are in pairs, we can just xor the whole array. After that we use operation to get one bit from the xor number and make a mask from it. We can achieve this by using the properties of how computers save negative numbers. 2's complement. Each number made negative is the number positive with all digits flipped, +1. If we take these numbers, for example 1101 which is 13, and -13 which is 0010+1=0011. If we look at the numbers we can see something that can greatly help us, we have successfully identified last bit by x&(-x). This works because by taking -x we switch all the bits, so all zeroes are ones and all ones are zeroes, that means that an and will yield zero except for the digits affected by the +1. This is determined only by the place of the last one in the original number. Since the position of the last one means after in (in all moreSB) there are zeroes, which makes it a 1 when switched, by adding 1 we switch all of them back to zero and the last 1 that is now a 0 will be 1 again since the addition rippled all the way to the first 0 in negative x which will become a 1. Therefore the numbers will be exact opposites until the least significant 1 in x, then x will have all zeroes and -x will also have all zeroes since it had all ones which we ripple added back to the original one by doing +1. With this, we have isolated the bit that is definitely different in both of the numbers that are alone in the array. That is a mask. The we create num1 and num2 and a for loop. We loop through the whole array, if the mask outputs 0 we do num^num1 else we do num^num2. Since the numbers in pairs are the same both of them will go into same numbers and cancel out. The mask will filter the number that had a 0 in the position where bit is to num1 and the number with a 1 to num2. Then we return {num1, num2}.