Given an integer array nums, return the length of the longest strictly increasing subsequence.

Strategy: This one looks easy, then hard. It is a DP problem and with a twist. Since it is a subsequence, it means we can skip numbers, they just need to keep order. The key is this: We save the longest subsequence up until all numbers. Then we can use that to choose if we append the new number at index i to that subsequence or not. The best strategy is to have a nested loop, one looping through all the characters, and the inner one going from 0 to current character excluded. We get the current number, and go back in the array to search in dp[] whats the largest possible array we could append our number to. We do this with if(number[currentindex]>number[previousindex]), if it is we call dp[i]=max(dp[j]+1, dp[i]), finding the highest possible this way. We reiterate until we get to the end of nums where we return the maximum value in the whole dp array tracked by a max(max, dp[i]) call at every index.